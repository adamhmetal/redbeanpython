# Supported types

The idea of RedBeanPython is to focus on Python types instead of SQL-like types. So instead of focusing on SQLAlchemy `String` vs `Text` or `Integer` vs `BigInteger`, you can concentrate on Python types like `str` or `int`.

RedBeanPython supports the storage of the following Python types:

- `bool`
- `int`
- `float`
- `decimal`
- `str`
- `datetime` 
- `date`
- `bytes`

## Types auto detection

The first usage determines types. (First storage in the database)

```python
bean = Bean('user')
bean.name = "Adam"
bean.start_date_time = datetime.now()
bean.start_date = date.today()
bean.count = 1
bean.ratio = 1.1
bean.price = Decimal("1.1")
bean.binary_code = b"123"
```

The first usage determines types. It is very **efficient in the development stage** but, at the same time, is **safe for production** as production database practice is to be _frozen_ (check [Freezing database](#freezing-database)). As a good practice, we check all autogenerated database migrations before committing them to the repository and deploying them on production.

**no matter what happens, the production database will not be changed without our explicit permission**.   

## Nullable

All types are nullable by default.

## Id

Id is always stored as `String(255)`, and its type can not be enforced. 

## (Advanced) Deep into used database types

By default, to have confidence, all possible variations of values that can go in future will be stored successfully; RedBeanPython always uses a type that covers the maximum range.

For example:

```python
bean.name = "Adam"
bean.count = 1
bean.price = Decimal(1.1)
# ect.
redbean.store(bean)
```

In theory, those values can be stored in the database as, consecutively: 

- SQLAlchemy String(4) (in DB: varchar(4)),
- SmallInteger (in DB: smallint (2 bytes))
- Decimal(precision=2,scale=1) (in DB: decimal(2,1))

But in practice, with autodetection, we do not know what values will be stored in future, so we need to use the type that covers the maximum range.

What if, after freezing the database, the production system will try to store values that are out of range of column type? For example:
```python
bean.name = "Longer name"
bean.count = 1_000_000
bean.price = Decimal(1001.1005)
redbean.store(bean)
```

That's why auto detection will always use the maximum range type.

- `int` -> `BigInteger` (8 bytes)`
- `float` -> `Double` (8 bytes)
- `decimal` -> `Numeric(precision=30, scale=10)` (17 bytes)
- `str` -> `Text` (dynamic size)

In the case of `str`:

As they are dynamic, there is no redundant storage needed.

And looking from a performance point of view:

- in the case of PostgreSQL: there is no problem at all. There is no performance difference between `text` and `varchar`.
- in the case of MySQL, there is a performance drop. Because TEXTs are stored outside the row and have to be loaded first. It is usually OK in practice, but consider PostgreSQL usage if you expect more data to be stored/loaded/searched.       


If, in your system, you achieve the amount of data on which this starts to be a problem (f.e. that 4 or 6 redundant bytes per integer row is a problem), then it means your project is mature enough to alter tables to smaller types and switch to SQLAlchemy as id described in [Hybrid mode](hybrid_mode.md).

#
# ___