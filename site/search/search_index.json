{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RedBeanPython","text":""},{"location":"#idea","title":"Idea","text":"<p>One of Python's most significant advantages is that we can make applications fast. Boilerplate is low, but we can focus on business logic, quickly deliver value, and make projects production-ready. But even if, with current powerful libraries, \"time-to-market\" is low, it can be lowered even more.</p> <p>The idea of RedBeanPython ORM is to decrease the time to market for applications by providing an absolutely zero configuration ORM and, simultaneously, heaving the possibility of zero effort transition to advanced ORM when needed.</p> <p>RedBeanPython idea is inspired by the matured RedBeanPHP ORM (since 2009 and still running).</p> <p>RedBeanPython ORM's idea is not to replace the more advanced ORMs (we should not reinvent the wheel) but to cooperate with them. Initially, it can be used as only ORM. When projects evolve, both code bases (RedBeanPython and SQLAlchemy) can coexist and, finally, can be swiftly replaced by SQLAlchemy (if needed).</p> <p> </p> <p> </p>"},{"location":"#lets-see-an-example-of-a-usual-project-lifecycle","title":"Let's see an example of a usual project lifecycle.","text":""},{"location":"#stage-1-development","title":"Stage 1. Development","text":"<p>We are starting a fresh project. We have an Idea, and we want to deliver MVP to production as soon as possible.</p> <p>We have an empty database (or no database at all at that moment).</p> <p>Let's store some data:</p> <pre><code>from datetime import datetime\nfrom decimal import Decimal\n\nfrom redbeanpython import redbean, Bean\n\nredbean.setup(dsn=False) #(1)\n\nuser = Bean('user')\nuser.name = 'Adam'\nuser.age = 42\nuser.subscription_price = Decimal(\"12.20\")\nuser.subscription_end = datetime.fromisoformat('2024-10-08T16:20:00')\n\nredbean.store(user)\n</code></pre> <ol> <li>For a temporary SQLite database call <code>redbean.setup(dsn=False)</code>.      For a production database, DSN consistent with SQLAlchemy should be provided.      See connection for more details.      For example, you may run a docker container with PostgreSQL:     <pre><code>docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass -d postgres\n</code></pre>     And use it:     <pre><code>redbean.setup('postgresql+psycopg://postgres:pass@localhost/postgres')\n</code></pre></li> </ol> <p>And that's all. </p> <p>No schema is need to be created, no migrations need to be run, no config files to update.</p> <p>Just run the code, and RedBeanPython will create everything automatically. </p> <p>If we take a look into db, we will see that table was created: <pre><code>create table user\n(\n    age                BIGINT,\n    id                 VARCHAR(255) not null primary key,\n    name               TEXT,\n    subscription_end   DATETIME,\n    subscription_price NUMERIC(30, 10)\n);\n</code></pre></p> <p>In the background, the SQLAlchemy model was created:</p> <pre><code>from sqlalchemy import Column, BigInteger, String, Text, DateTime, Numeric\n\nfrom redbeanpython import Model\n\n\nclass User(Model):\n    __tablename__ = 'user'\n    __table_args__ = {'extend_existing': True}\n\n    age = Column(BigInteger, nullable=True)\n    id = Column(String(255), primary_key=True)\n    name = Column(Text, nullable=True)\n    subscription_end = Column(DateTime, nullable=True)\n    subscription_price = Column(Numeric(precision=30, scale=10), nullable=True)\n\n    def __json__(self):\n        return self.as_dict()\n\n    def as_dict(self):\n        return {\n            'age': self.age,\n            'id': self.id,\n            'name': self.name,\n            'subscription_end': self.subscription_end,\n            'subscription_price': self.subscription_price,\n        }\n</code></pre> <p>We do not need this information now, but it might be helpful later. (See section: hybrid mode)</p> <p>Let's load it from the database, and as we see, the types are preserved:</p> <pre><code>&gt;&gt;&gt; from redbeanpython import redbean\n&gt;&gt;&gt; redbean.setup(dsn=False)\n&gt;&gt;&gt; users = list(redbean.find('user'))\n&gt;&gt;&gt; user = users[0]\n&gt;&gt;&gt; print(dict(user))\n{\n    'age': 42, \n    'id': '1f0e6e46-6e47-404f-9547-9dc3e9741ec6', \n    'name': 'Adam', \n    'subscription_end': datetime.datetime(2024, 10, 8, 16, 20), \n    'subscription_price': Decimal('12.2000000000')\n}\n&gt;&gt;&gt; print(type(user.subscription_end), user.subscription_end)\n&lt;class 'datetime.datetime'&gt; 2024-10-08 16:20:00\n</code></pre>"},{"location":"#_1","title":"Welcome","text":"<p>Let's go on; development continues.</p> <p>In the early stage of the project, life changes are widespread. Often, we even rewrite the first ideas.</p> <p>With RedBeanPython, this is no problem; we can change the code and run it again. RedBeanPython will adjust everything automatically.</p> <p>For example, we decided that the user should have a birthday. We can add in code:</p> <pre><code># ...\nuser.birthday = date.fromisoformat('1981-12-01')\n# ...\n</code></pre> <p>And rerun it. RedBeanPython will adequately adjust the database schema. </p> <p>The database schema has been adjusted.</p> <pre><code>create table user\n(\n    age                BIGINT,\n    id                 VARCHAR(255) not null primary key,\n    name               TEXT,\n    subscription_end   DATETIME,\n    subscription_price NUMERIC(30, 10),\n    birthday           DATE  -- (1)\n);\n</code></pre> <ol> <li>A new column was added.</li> </ol> <p>Same as model:</p> <pre><code>class User(Model):\n    # (...)\n    name = Column(Text, nullable=True)\n    subscription_end = Column(DateTime, nullable=True) # (1)\n    subscription_price = Column(Numeric(precision=30, scale=10), nullable=True)\n    # (...)\n\n    def as_dict(self):\n        return {\n            # (...)\n            'name': self.name,\n            'subscription_end': self.subscription_end, # (2)\n            'subscription_price': self.subscription_price,\n        }\n</code></pre> <ol> <li>A new property was added.</li> <li>A new property was added.</li> </ol> <p>And alembic migration was created automatically: <pre><code>def upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    with op.batch_alter_table('user', schema=None) as batch_op:\n        batch_op.add_column(sa.Column('birthday', sa.Date(), nullable=True))\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    with op.batch_alter_table('user', schema=None) as batch_op:\n        batch_op.drop_column('birthday')\n</code></pre></p> <p> Migrations will be useful later when the project is production-ready.</p>"},{"location":"#_2","title":"Welcome","text":"<p>Now, when we have MVP ready, we can go to production.</p>"},{"location":"#stage-2-production","title":"Stage 2: Production","text":"<p>When the project stays production-ready, we would like to freeze production database to avoid potential unexpected changes.  No automatic changes will be made to production since that moment. </p> <p>To freeze the database, we just need to add one parameter to <code>redbean.setup()</code> call:</p> <pre><code>redbean.setup('...', frozen=True)\n</code></pre> <p>Or use <code>REDBEAN_DB_FROZEN=1</code> environment variable.</p> <p>And, from that time on production, we can use alembic migrations to manage production database schema changes safely. We fully control how and when the database schema will be changed.</p> <p>Because alembic migrations are created automatically by RedBeanPython, we can just run:</p> <pre><code>cd redbean/migrations \nDB_DSN=\"sqlite:////tmp/redbean.sqlite\" alembic upgrade head\n</code></pre> <p>on production to apply all changes.</p> <p>At the same time, everything will work as before in the development environment, and we still have all the benefits from automatic creation. </p>"},{"location":"#stage-3-project-growth","title":"Stage 3: Project growth","text":"<p>When the project grows, we may need more performance or more sophisticated database features. As RedBeanPython is not intended to be a replacement for SQLAlchemy, instead of extending RedBeanPython forever, we can switch to SQLAlchemy ORM and take full advantage of the giants. </p> <p>Moreover, we can use both ORMs simultaneously and switch to more advanced ORMs with zero effort for specific cases only.</p> <p>As SQLAlchemy Models has already been created automatically, we can use it. </p> <p>Let's see how it works.</p> <pre><code>from redbean.models.customer import Customer\nfrom redbean.models.invoice import Invoice\n\nredbean.setup(dsn=False)\n\n# redbeanpython code\ncustomer = Bean('customer')\ncustomer.name = 'John'\n\ninvoice = Bean('invoice')\ninvoice.amount = Decimal(\"12.20\")\ninvoice.customer_id = customer.id\n\nredbean.store_many([invoice, customer])\n\n# sqlalchemy code\nsession = redbean.session_maker()\nquery = session.query(Customer, Invoice)\nquery = query.filter(Customer.id == Invoice.customer_id)\nquery = query.filter(Invoice.amount &gt; 10)\nresult = query.all()\nfor customer, invoice in result:\n    print(customer.name, invoice.amount)\n\nquery = session.query(\n    Invoice.customer_id,\n    func.count('*').label('amount'),\n    func.sum(Invoice.amount).label('amount'),\n)\nquery = query.group_by(Invoice.customer_id)\nfor customer_id, invoices_count, invoices_total, in query.all():\n    print(f\"{customer_id} has: {invoices_count} invoices with a sum: {invoices_total}\")\n\n    # redbeanpython code again\n    print(customer_id)\n    customer = redbean.load('customer', customer_id)\n    print(dict(customer))\n</code></pre> <p>We can freely mix both ORMs in the same code base. This is a hybrid mode.</p> <p>Finally, when our project succeeds, it will be on the market for months or years. Development team grows. Codebase enlarges - we can want to switch to SQLAlchemy ORM entirely.</p>"},{"location":"#stage-4-maturity","title":"Stage 4: Maturity","text":"<p>When the project matures and we decide to switch entirely to SQLAlchemy ORM, we can say goodbye to RedBeanPython methods and start to use SQLAlchemy only.</p> <p>Starting with previously automatically generated Models, we will continue to extend them and work with them in a standard SQLAlchemy way.</p> <p>And then you can let RedBeanPython go. RedBeanPython did its job. It's time for retirement.</p> <p>It was a beautiful journey!</p>"},{"location":"#_3","title":"Welcome","text":""},{"location":"#___","title":"___","text":""},{"location":"beans/","title":"Beans","text":"<p>All operations in RedBeanPython are done on Beans objects. Beans works similar, but not identical, as ORM objects in other ORM libraries.</p> <p>Bean object makes use of the corresponding (autogenerated) SQLAlchemy Model (if you want to know more, see hybrid mode)</p>"},{"location":"beans/#dispense","title":"Dispense","text":"<p>Beans can be created just by passing their type to the Bean class.</p> <pre><code>user = Bean('user')\n</code></pre> <p>And their property can be added just as an object property:</p> <pre><code>user.name = \"Adam\"\nuser.age = 42\n</code></pre> <p>or via a dictionary-like interface</p> <pre><code>user['name'] = \"Adam\"\nuser['age'] = 42\n</code></pre>"},{"location":"beans/#an-alternative-way-to-create-beans-is-to-use-the-dispense-method-on-engine-object","title":"An alternative way to create beans is to use the <code>dispense</code> method on engine object","text":"<pre><code>user = redbean.dispense('user')\nuser['name'] = \"Adam\"\nuser['age'] = 42\n</code></pre>"},{"location":"beans/#dispense-many","title":"Dispense many","text":"<p>Use <code>Beans()</code> syntactic sugar notation to dispense many beans at once.</p> <pre><code>users = Beans('user', count=10) # (1)\n# ... fill beans with data...\nredbean.store_many(users)\n\nusers = Beans('user', data=[{\"name\": \"Adam\"}, {\"name\": \"Eve\"}]) # (2)\nredbean.store_many(users)\n</code></pre> <ol> <li>will dispense ten empty beans</li> <li>will dispense beans from the list of dict data</li> </ol> <p>An alternative syntax is to use <code>dispense_many</code> method</p> <pre><code>users = redbean.dispense_many('user', count=10) #(1)\n# ... fill beans with data...\nredbean.store_many(users)\n\nusers = redbean.dispense_many('user', data=[{\"name\": \"Adam\"}, {\"name\": \"Eve\"}]) #(2)\nredbean.store_many(users)\n</code></pre> <ol> <li>will dispense ten empty beans</li> <li>will dispense beans from the list of dict data</li> </ol> <p> <code>store_many</code> is a syntactic sugar only. It will not store records in bulk. It will be enough for most situations, but if you need to speed up storing many records at once, use Bulk operations</p>"},{"location":"beans/#cast-to-dict","title":"Cast to dict","text":"<p>For convenience, beans can be cast to dict with the standard Python way:</p> <pre><code>user = Bean('user')\nuser['name'] = \"Adam\"\nuser['age'] = 42\nprint(dict(user))\n\nredbean.store(user)\n\nloaded = redbean.load('user', user.id)\nprint(dict(loaded))\n</code></pre> <pre><code>{\n    'age': 42,\n    'id': 'ab58f89d-5543-4e94-a3c8-854674c420f4', \n    'name': 'Adam'\n}\n</code></pre>"},{"location":"beans/#_1","title":"Beans (Models)","text":""},{"location":"beans/#___","title":"___","text":""},{"location":"bulk_operations/","title":"Bulk operations","text":"<p>Bulk operations are designed to decrease the number of requests sent to databases.</p> <p>With many records to store or update, you should consider using bulk operations.</p> <p>Bulk operations are out of the scope of RedBeanPython by design, as if we have such use cases, hybrid mode and SQLAlchemy should be used directly in such places.</p>"},{"location":"bulk_operations/#bulk-store","title":"Bulk store","text":"<p>A bulk store is used to store many beans at once (with single request).</p> <pre><code>from sqlalchemy import insert\n\nwith redbean.session_maker() as session:\n    session.execute(\n         insert(User),\n         [\n             {\"id\": \"a\", \"name\": \"Adam\", \"age\": 42},\n             {\"id\": \"i\", \"name\": \"Ivona\", \"age\": 42},\n             {\"id\": \"h\", \"name\": \"Hanna\", \"age\": 10},\n             {\"id\": \"e\", \"name\": \"Eva\", \"age\": 7},\n         ],\n    )\n    session.commit()\n</code></pre>"},{"location":"bulk_operations/#bulk-update","title":"Bulk update","text":"<p>A bulk update is used to update many beans at once (with a single request).</p> <pre><code>from sqlalchemy import update\n\nwith redbean.session_maker() as session:\n    session.execute(\n         update(User),\n         [\n             {\"id\": \"a\", \"name\": \"Adam\", \"age\": 43},\n             {\"id\": \"i\", \"name\": \"Ivona\", \"age\": 43},\n             {\"id\": \"h\", \"name\": \"Hanna\", \"age\": 11},\n             {\"id\": \"e\", \"name\": \"Eva\", \"age\": 8},\n         ],\n    )\n    session.commit()\n</code></pre>"},{"location":"bulk_operations/#_1","title":"Bulk operations","text":""},{"location":"bulk_operations/#___","title":"___","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#101","title":"1.0.1","text":"<p>2021-02-04</p> <p>Documentation fixes.</p>"},{"location":"changelog/#100","title":"1.0.0","text":"<p>2021-02-01</p> <p>First release (production-ready).</p>"},{"location":"changelog/#_1","title":"Changelog","text":""},{"location":"changelog/#___","title":"___","text":""},{"location":"connection/","title":"Connection","text":"<p>RedBeanPython works with PostgreSQL, MySQL/MariaDB and SQLite.</p>"},{"location":"connection/#setup-via-env","title":"Setup via ENV","text":"<p>A typical pattern for setting up a RedBeanPython connection is setting the environment variable <code>REDBEAN_DB_DSN</code>.</p> <p>F.e. for PostgreSQL:</p> <p><code>REDBEAN_DB_DSN=postgresql+psycopg://user:pass@host/dbname</code></p> <p>If <code>REDBEAN_DB_DSN</code> is set, it will be used as DSN for database connection just by calling:</p> <pre><code>from redbeanpython import redbean\nredbean.setup() # (1)\n</code></pre> <ol> <li><code>dsn=os.environ.get('REDBEAN_DB_DSN')</code> =&gt; <code>postgresql+psycopg://user:pass@host/dbname</code></li> </ol>"},{"location":"connection/#test-database","title":"Test database","text":"<p>To connect to an SQLite testing database, use:</p> <pre><code>from redbeanpython import redbean\nredbean.setup(dsn=False)\n</code></pre> <p>It will create SQLite test database <code>redbean.sqlite</code>  in the system's temporary directory and connect to it.</p> <p> Remember that, in most operating systems, this database will be deleted after the system reboots.</p>"},{"location":"connection/#real-database-connection","title":"Real database connection","text":""},{"location":"connection/#postgresql-recommended","title":"PostgreSQL (recommended)","text":"<p>PostgreSQL is the recommended database for production use. RedBeanPython performs best with it.</p> <p>DSN (consistent with SQLAlchemy):</p> <pre><code>redbean.setup('postgresql+psycopg://user:pass@host/dbname')\n</code></pre>"},{"location":"connection/#example","title":"Example","text":"<p>Run dockerized PostgreSQL:</p> <pre><code>docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass -d postgres\n</code></pre> <p>and connect to it:</p> <pre><code>from redbeanpython import redbean\nredbean.setup('postgresql+psycopg://postgres:pass@localhost/postgres')\n</code></pre>"},{"location":"connection/#mysqlmariadb","title":"MySQL/MariaDB","text":"<p>MySQL (because of how it supports TEXT type) performs worse than PostgreSQL but is still a good choice for production use.</p> <p>DSN (consistent with SQLAlchemy):</p> <pre><code>redbean.setup('mysql+pymysql://user:pass@host/dbname')\n</code></pre>"},{"location":"connection/#example_1","title":"Example","text":"<p>Run dockerized MySQL:</p> <pre><code>docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=pass -e MYSQL_DATABASE=db -d mysql\n</code></pre> <p>or MariaDB:</p> <pre><code>docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=pass -e MYSQL_DATABASE=db -d mariadb\n</code></pre> <p>and connect to it:</p> <pre><code>from redbeanpython import redbean\nredbean.setup('mysql+pymysql://root:pass@localhost/db')\n</code></pre>"},{"location":"connection/#sqlite","title":"SQLite","text":"<p>SQLite is a good choice for system/cli applications but is not recommended for web applications.  </p> <p>DSN (consistent with SQLAlchemy):</p> <pre><code>redbean.setup('sqlite:///path/to/database.db')\n</code></pre>"},{"location":"connection/#switching-to-another-database-during-time-of-development","title":"Switching to another database during time of development","text":"<p>  If we switch to other database during development, we must synchronize the database schema with the code.</p> <p>The fastest solution in the development environment is to remove models and migrations from the directory.</p> <p>It can be done manually or by using the <code>clear_models</code> command:</p> <pre><code>redbean clear_models\n</code></pre> <p>Alternatively, instead of recreating models, we can run migrations against the new database:</p> <p>For example, if we switch from <code>db</code> to <code>new_db</code> database:</p> <pre><code>cd redbean/migrations \nDB_DSN=\"mysql+pymysql://root:pass@localhost/new_db\" alembic upgrade head\n</code></pre> <p> New database must not contain <code>alembic_version</code> table or any previously created by RedBeanPython.</p>"},{"location":"connection/#sqlite-limitations","title":"SQLite limitations","text":"<p>Limited types are supported by SQLite: datetime, date, decimal, and boolean are stored in SQLite in broad data types and made programmatically by the database engine.</p> <p>From your perspective, internal types do not affect your code; everything works like other databases, and you do not need to consider any code changes.</p> <p>With one exception, as SQLite  <code>Decimals</code> (emulated) are limited to <code>precision+scale &lt;= 10</code>, you must consider switching to Postgres or Mysql if your use cases exceed that limit.  </p> <p>In addition, remember that it is a file-based database; because of that, SQLite's ability to work with more than one connection simultaneously is minimal. (Remember this if you are using the async code.) Even if the Python SQLite library should take care of locking inside one Python process, it will be a problem when more processes are running independently. (i.e., a few different workers trying to access the same SQLite database. Because of that, it is suggested to use it only for development or, if you are sure, our app will be single-process only. (You should not use SQLite, for example, for web applications (asynchronous by idea).    </p>"},{"location":"connection/#_1","title":"Connection","text":""},{"location":"connection/#___","title":"___","text":""},{"location":"conventions/","title":"Conventions","text":""},{"location":"conventions/#via-facade-recommended","title":"Via Facade (recommended):","text":"<p>You can use RedBeanPython via the facade instance initialized in the <code>redbeanpython</code> package. This way is recommended because it will provide consistent usage of the same engine throughout the whole project.</p> <p>Just import the <code>redbeanpython</code> package and call the <code>setup</code> method to use it.</p> <pre><code>from redbeanpython import redbean\n\nredbean.setup(dsn=False)\nuser = redbean.load('user', '1234')\n</code></pre> <p>Or, if you prefer, as a short alias:</p> <pre><code>from redbeanpython import r\n\nr.setup(dsn=False)\nuser = r.load('user', '1234')\n</code></pre> <p>Both usages will use a facade that proves consistent usage of the same engine in the project.</p>"},{"location":"conventions/#directly","title":"Directly:","text":"<p>The third way is to use the <code>RedBean</code> class directly. This way can be helpful: - if you want to use it in your own dependency manager, - if you want to connect to multiple databases in one project, - in automatic tests.</p> <pre><code>from redbeanpython import RedBean\n\nredbean = RedBean(dsn=False)\nuser = redbean.load('user', '1234')\n</code></pre>"},{"location":"conventions/#naming","title":"Naming","text":"<p>Allowed names (for beans and its properties):</p> <ul> <li>have to be proper identifiers. (It can contain only letters, digits, and underscores and can not start with a digit.)</li> <li>have to be snake_case.</li> <li>must not start with an underscore.</li> </ul> <p>Examples:</p> <pre><code># allowed\nbean = Bean('user')\nbean = Bean('admin_user')\nbean.id = \"...\"\nbean.name = \"...\"\nbean.other_name_2 = \"...\"\n\n# not allowed\nbean = Bean('User')\nbean = Bean('adminUser')\nbean.name = \"...\"\nbean.Name = \"...\"\n</code></pre>"},{"location":"conventions/#id","title":"Id","text":"<p>Every bean has <code>id</code> property. It has to be a string (or <code>Id</code> class). If it is not set during object creation, then it is, by default, an autogenerated UUID4 string.</p> <p>The decision to resign from the autoincrement integer was taken for security reasons: it is not possible to guess other objects' id, and it is not possible to iterate over all objects. For example, in case of potential problems with proper user authorization, the user can not steal other users' data just by asking for their next/previous IDs.  </p>"},{"location":"conventions/#restricted-keywords","title":"Restricted keywords:","text":"<ul> <li><code>keys</code> can not be used as a property name (because is used internally by Python during casting bean object to dict <code>dict(bean)</code>)</li> </ul>"},{"location":"conventions/#_1","title":"Conventions","text":""},{"location":"conventions/#___","title":"___","text":""},{"location":"crud/","title":"CRUD","text":""},{"location":"crud/#create","title":"Create","text":"<p>Use <code>redbean.store(bean)</code> to store the bean in the database.</p> <pre><code>user = Bean('user')\nuser.name = \"Adam\"\nuser.age = 42\nredbean.store(user)\n</code></pre> <p>By default, id is an autogenerated UUID4 string. <pre><code>print(user.id)\n</code></pre> <pre><code>757dc644-f1e2-4d1a-b44e-829b62d8d4ae\n</code></pre></p> <p>Optionally id can be overridden.</p> <pre><code>user = Bean('user')\nuser.id = \"my_own_id_1234\"\nuser.name = \"Adam\"\nuser.age = 42\nredbean.store(user)\n</code></pre> <p>If a user with a given id already exists in the database, it will be updated.</p> <p> <code>store()</code> operation is idempotent. No exception will be thrown if a bean with a given ID already exists in the database.</p>"},{"location":"crud/#an-alternative-way-to-create-beans-is-to-use-the-dispense-method-on-engine-object","title":"An alternative way to create beans is to use the <code>dispense</code> method on engine object","text":"<pre><code>user = redbean.dispense('user')\nuser['name'] = \"Adam\"\nuser['age'] = 42\n</code></pre>"},{"location":"crud/#create-many","title":"Create many","text":"<p>Use <code>Beans()</code> syntactic sugar notation to dispense many beans at once.</p> <pre><code>users = Beans('user', count=10) # (1)\n# ... fill beans with data...\nredbean.store_many(users)\n\nusers = Beans('user', data=[{\"name\": \"Adam\"}, {\"name\": \"Eve\"}]) # (2)\nredbean.store_many(users)\n</code></pre> <ol> <li>will dispense ten empty beans</li> <li>will dispense beans from the list of dict data</li> </ol>"},{"location":"crud/#an-alternative-syntax-is-to-use-dispense_many-method","title":"An alternative syntax is to use <code>dispense_many</code> method","text":"<pre><code>users = redbean.dispense_many('user', count=10) #(1)\n# ... fill beans with data...\nredbean.store_many(users)\n\nusers = redbean.dispense_many('user', data=[{\"name\": \"Adam\"}, {\"name\": \"Eve\"}]) #(2)\nredbean.store_many(users)\n</code></pre> <ol> <li>will dispense ten empty beans</li> <li>will dispense beans from the list of dict data</li> </ol> <p> <code>store_many</code> is a syntactic sugar only. It will not store records in bulk. It will be enough for most situations, but if you need to speed up storing many records at once, use Bulk operations</p>"},{"location":"crud/#read","title":"Read","text":"<pre><code>user = redbean.load('user', user_id)\n</code></pre> <p>If a bean with a given id does not exist in the database, it will be created by default.</p> <p>Optionally, it may be called with <code>throw_on_empty=True</code> to throw <code>NotExistsError</code> if a bean with a given id does not exist in the database. <pre><code>from redbeanpython import NotExistsError\n\ntry:\n    user = redbean.load('user', user_id, throw_on_empty=True)\nexcept NotExistsError:\n    ...\n</code></pre></p>"},{"location":"crud/#load-many","title":"Load many","text":"<p>To load many beans at once, use <code>load_many</code> method of the redbean object</p> <pre><code>users = redbean.load_many('user', [user_id_1, user_id_2, user_id_3])\n\nusers = redbean.load_many(\n    'user',\n    [user_id_1, user_id_2, user_id_3],\n    throw_on_empty=True,\n)\n</code></pre> <p> <code>load_many</code> is a syntactic sugar only. It will not load records in bulk. It will be enough for most situations, but if you need to speed up loading many records at once, use Bulk operations</p>"},{"location":"crud/#update","title":"Update","text":"<pre><code>user = redbean.load('user', user_id)\nuser.name = \"New name\"\nredbean.store(user)\n</code></pre>"},{"location":"crud/#update-many","title":"Update many","text":"<p>Check create many section for more details.</p>"},{"location":"crud/#delete","title":"Delete","text":"<p>We can delete loaded bean:</p> <pre><code>user = redbean.load('user', user_id)\nredbean.delete(bean=user)\n</code></pre> <p>or we can delete without loading bean via id and type:</p> <pre><code>redbean.delete(bean_type='user', bean_id=user_id)\n</code></pre> <p> <code>delete()</code> operation is idempotent. No exception will be thrown if a bean with the given ID does not exist in the database.</p>"},{"location":"crud/#_1","title":"CRUD","text":""},{"location":"crud/#___","title":"___","text":""},{"location":"custom_configuration/","title":"Configuration","text":"<p>As the idea of RedBeanPython is to be as zero-config ORM, by default, no configuration is needed.</p> <p>But you can do it if you want to change the default directory/namespace and adjust it to your needs and project structure.</p>"},{"location":"custom_configuration/#directory-and-namespace-configuration","title":"Directory and namespace configuration","text":"<p>By default, RedBeanPython will create models in the <code>redbean</code> directory in the app's main directory and use the corresponding namespace. </p> <p>But it can be changed by calling <code>redbean.setup()</code> with <code>directory</code> and <code>namespace</code> parameters.</p> <pre><code>redbean.setup(\n    \"postgresql+psycopg://...\", \n    directory='my_module/my_redbean', \n    namespace='my_module.my_redbean'\n)\n</code></pre> <p>or by setting <code>REDBEAN_DIRECTORY</code> and <code>REDBEAN_NAMESPACE</code> environment variables.</p> <pre><code>REDBEAN_DIRECTORY=my_module/my_redbean\nREDBEAN_NAMESPACE=my_module.my_redbean\n</code></pre> <p>In the above example, models will be created in <code>my_module/my_redbean</code> directory  and will be available as <code>my_module.my_redbean</code> namespace.</p>"},{"location":"custom_configuration/#_1","title":"Configuration","text":""},{"location":"custom_configuration/#___","title":"___","text":""},{"location":"finding/","title":"Find, Count, Exists","text":""},{"location":"finding/#finding","title":"Finding","text":"<p>The finding can be done by query and parameters with the syntax consistent with SQLAlchemy.</p> <pre><code>result: Iterator[Bean] = redbean.find(  #(1)\n    'user', \n    query=\"age &gt; :age and active = :active\", \n    params={\"age\": 21, \"active\": True},\n    order=\"age desc\",\n    limit=10,\n    offset=20,\n)\n\nresult: Iterator[Bean] = redbean.find(  #(2)\n    'user', \n    query=\"age &gt; :age and active = :active\", \n    params={\"age\": 21, \"active\": True},\n)\n\nresult: Iterator[Bean] = redbean.find('user')  #(3)\n</code></pre> <ol> <li>Find all records of type <code>user</code> with <code>age &gt; 21</code> and <code>active = True</code> ordered by <code>age desc</code> with limit <code>10</code> starting from offset <code>20</code>.</li> <li>Find all records of type <code>user</code> with <code>age &gt; 21</code> and <code>active = True</code>.</li> <li>Find all records of type <code>user</code>.</li> </ol> <p> Find can be safely run against not existing (at that moment) bean types (tables).  </p> <p><pre><code>print(list(redbean.find('not_existing_yet_in_database')))\n</code></pre> <pre><code>[]\n</code></pre></p>"},{"location":"finding/#alternative-syntax","title":"Alternative syntax","text":"<p>If you do not want to use a text query with parameters, you can use SQLAlchemy. (Hybrid mode). The main difference is that the result object is <code>list[Model]</code>, not <code>Iterator[Bean]</code>.</p> <pre><code>with redbean.session_maker() as session:\n    query = session.query(User)\n    query = query.filter(User.age &gt; 21)\n    query = query.filter(User.active == True)\n    query = query.order_by(User.age.desc())\n    query = query.limit(10)\n    query = query.offset(20)\n    result: list[User] = query.all()\n    for user in result:\n        print(user.as_dict())\n</code></pre>"},{"location":"finding/#counting","title":"Counting","text":"<p>Counting can be done by query and parameters with syntax consistent with SQLAlchemy.</p> <pre><code>count: int = redbean.count( #(1)\n    'user', \n    query=\"age &gt; :age and active = :active\", \n    params={\"age\": 21, \"active\": True}\n)\n\ncount: int = redbean.count('user') #(2)\n</code></pre> <ol> <li>Count records of type <code>user</code> with <code>age &gt; 21</code> and <code>active = True</code>.</li> <li>Count all records of type `user</li> </ol> <p> Count can be safely run against not-existing (at that moment) bean types (tables). </p> <p><pre><code>print(redbean.count('not_existing_yet_in_database'))\n</code></pre> <pre><code>0\n</code></pre></p>"},{"location":"finding/#alternative-syntax_1","title":"Alternative syntax","text":"<p>If you do not want to use a text query with parameters, you can use SQLAlchemy. Hybrid mode.</p> <pre><code>with redbean.session_maker() as session:\n    query = session.query(User)\n    query = query.filter(User.age &gt; 21)\n    query = query.filter(User.active == True)\n    count: int = query.count()\n</code></pre>"},{"location":"finding/#checking-the-existence-of-a-bean","title":"Checking the existence of a bean","text":"<p>Existence can be checked with the <code>exists</code> method.</p> <pre><code>is_exists: bool = redbean.exists('user', bean_id=user_id)\n</code></pre> <p> It can be safely run against not-existing (at that moment) bean types (tables).</p> <p><pre><code>print(redbean.exists('not_existing_yet_in_database', bean_id=\"some_id\"))\n</code></pre> <pre><code>False\n</code></pre></p>"},{"location":"finding/#_1","title":"Find, count, exists","text":""},{"location":"finding/#___","title":"___","text":""},{"location":"fluid_frozen/","title":"Fluid, Frozen mode","text":"<p>By default, in development mode, RedBeanPython is in fluid mode. </p> <p>It means it will create new columns in the database if they are absent. It will also add new fields to the model. And take care of all migrations in the background.</p> <p>Fluid mode is very convenient for development, but it is not recommended for production.</p> <p>On production, you should use frozen mode. In frozen mode, RedBeanPython will not modify anything in the database.</p> <p>Because RedBeanPython will create alembic migrations automatically during development (in fluid mode), all that needs to be done is to run alembic migrations on production. </p>"},{"location":"fluid_frozen/#freezing-database","title":"Freezing database","text":"<p>To freeze the database, add <code>frozen=True</code> to <code>redbean.setup()</code> call like:</p> <pre><code>redbean.setup(dsn=False, frozen=True)\n</code></pre> <p>Or use <code>REDBEAN_DB_FROZEN</code> environment variable:</p> <pre><code>REDBEAN_DB_FROZEN=1\n</code></pre> <p>Since then, no automatic changes have been made to the database.</p> <p>In addition, there will be no automatic model changes. Models existing in the code base will be used without modifications.</p> <p>Because of that behaviour, we have full control over the database and models in the production environment.</p>"},{"location":"fluid_frozen/#running-migrations","title":"Running migrations","text":"<p>Alembic migrations are created by default in the namespace directory.</p> <p>Example directory structure: <pre><code>migrations\n    versions \n        1706519938318070_.py\n        1706519970704551_.py\n    env.py \nmodels\n    user.py\n</code></pre></p> <p>Migrations (on production) can be executed by running alembic migrations:</p> <pre><code>cd redbean/migrations \nDB_DSN=\"postgresql+psycopg://user:pass@host/dbname\" alembic upgrade head\n</code></pre>"},{"location":"fluid_frozen/#_1","title":"Fluid and Frozen (Production). Migrations","text":""},{"location":"fluid_frozen/#___","title":"___","text":""},{"location":"hybrid_mode/","title":"Hybrid mode","text":"<p>RedBeanPython and SQLAlchemy can be mixed together in one project. Hybrid Mode is the simultaneous usage of RedBeanPython and SQLAlchemy.</p> <p>It is as easy as everything else in RedBeanPython. Just use the SQLAlchemy session (from <code>redbean.session_maker</code>) and work with SQLAlchemy models created automatically for you.</p> <p>Like:</p> <pre><code>from sqlalchemy import func\n\nfrom redbean.models.customer import Customer\nfrom redbean.models.invoice import Invoice\n\nsession = redbean.session_maker() # (1)\nquery = session.query(Customer, Invoice) # (2)\nquery = query.filter(Customer.id == Invoice.customer_id)\nquery = query.filter(Invoice.amount &gt; 10)\nresult = query.all()\nfor customer, invoice in result:\n    print(customer.name, invoice.amount)\n\nquery = session.query(\n    Invoice.customer_id,\n    func.count('*').label('amount'), # (3)\n    func.sum(Invoice.amount).label('amount'),\n)\nquery = query.group_by(Invoice.customer_id)\nfor customer_id, invoices_count, invoices_total, in query.all():\n    print(f\"{customer_id} has: {invoices_count} invoices with a sum: {invoices_total}\")\n</code></pre> <ol> <li>Get SQLAlchemy session from redbean (single point of initialization)</li> <li>Use autogenerated (by redbean) SQLAlchemy model</li> <li>Use any SQLAlchemy feature you want</li> </ol> <p>You can freely mix RedBeanPython and SQLAlchemy in one project. </p> <p>The idea of RedBeanPython is to reduce the time-to-market of your project as much as possible. However, it is not intended to replace every advanced SQLAlchemy feature. Instead, the idea is to leave the full power of advanced SQLAlchemy whenever needed.  </p> <p>That way, you can work mix both usages as you prefer:</p> <ul> <li>You can use RedBeanPython as only ORM forever.</li> <li>You can start with RedBeanPython and switch to SQLAlchemy when the project matures. </li> <li>You can use RedBeanPython for simple tasks and SQLAlchemy for complex ones.</li> <li>You can use RedBeanPython for prototyping and rewrite to SQLAlchemy before production.</li> <li>You can use RedBeanPython just for auto-creating models, migrations and on-the-fly database structure modifications by using SQLAlchemy syntax from the beginning.</li> <li>And any other mix you want.</li> </ul>"},{"location":"hybrid_mode/#_1","title":"Act as SQLAlchemy","text":""},{"location":"hybrid_mode/#___","title":"___","text":""},{"location":"install/","title":"Installation","text":"<p>RedBeanPython is available on PyPI and can be installed with pip:</p> <pre><code>pip install redbeanpython\n</code></pre>"},{"location":"install/#pypi","title":"PyPI","text":"<p>RedBeanPython on PyPI</p>"},{"location":"install/#source-code","title":"Source code","text":"<p>Source code is available on GitHub.</p>"},{"location":"install/#requirements","title":"Requirements","text":"<p>RedBeanPython requires</p> <ul> <li>Python 3.11 or newer.</li> <li>SQLAlchemy 2.0 or newer.</li> <li>alembic 1.7 or newer.</li> </ul>"},{"location":"install/#database-requirements","title":"Database requirements","text":"<p>For PostgreSQL support RedBeanPython requires:</p> <ul> <li>psycopg2 2.9.9 or newer.</li> </ul> <p>For MySQL/MariaDB support RedBeanPython requires:</p> <ul> <li>PyMySQL 1.0.2 or newer.</li> </ul>"},{"location":"install/#_1","title":"Installation","text":""},{"location":"install/#___","title":"___","text":""},{"location":"joined_load/","title":"Joined load","text":"<p>Joined load is out of the scope of RedBeanPython by design, as if we have such use cases hybrid mode and sql alchemy directly should be used in such places.</p>"},{"location":"joined_load/#joined-load_1","title":"Joined load","text":"<pre><code>session = redbean.session_maker() # (1)\nquery = session.query(Customer, Invoice) # (2)\nquery = query.filter(Customer.id == Invoice.customer_id)\nquery = query.filter(Invoice.amount &gt; 10)\nresult = query.all()\nfor customer, invoice in result:\n    print(customer.name, invoice.amount)\n</code></pre> <ol> <li>Get SQLAlchemy session from redbean (single point of initialization)</li> <li>Use autogenerated (by redbean) SQLAlchemy model</li> <li>Add relations mapping</li> </ol> <p>The current RedBeanPython version does not support relations, so you have to do it manually. <pre><code># (...)\nquery = session.query(Customer, Invoice)\nquery = query.filter(Customer.id == Invoice.customer_id)\n# (...)\n</code></pre>  Relations are planned to be supported in further versions.</p>"},{"location":"joined_load/#_1","title":"Joined load","text":""},{"location":"joined_load/#___","title":"___","text":""},{"location":"licence/","title":"Licence","text":"<p>Licence: MIT</p>"},{"location":"licence/#_1","title":"About","text":""},{"location":"licence/#source-code","title":"Source code","text":"<p>Source code is available on GitHub.</p>"},{"location":"licence/#_2","title":"About","text":""},{"location":"licence/#issue-tracker","title":"Issue tracker","text":"<p>Issue tracker is available on GitHub.</p>"},{"location":"licence/#_3","title":"About","text":""},{"location":"licence/#contact","title":"Contact","text":"<p>Adam Puza: adampuza@redbeanpython.org</p>"},{"location":"licence/#_4","title":"About","text":""},{"location":"licence/#___","title":"___","text":""},{"location":"migration_to_sqlalchemy/","title":"SQLAlchemy differences","text":"<p>Hybrid Mode is the most efficient way of working with RedBeanPython and SQLAlchemy simultaneously.</p> <p>But if you want to go further and fully migrate to SQLAlchemy, you should be aware of some differences. </p>"},{"location":"migration_to_sqlalchemy/#findingcounting","title":"Finding/counting","text":"<p>The internal implementation of RedBeanPython is based on SQLAlchemy parametrized text queries.</p> <p>However, after switching to SQLAlchemy Models, using text queries becomes an antipattern. It would be best if you used SQLAlchemy syntax for model-based syntax.</p> <p>This RedBeanPython syntax:</p> <pre><code>count: int = redbean.count(\n    'user', \n    query=\"age &gt; :age and active = :active\", \n    params={\"age\": 21, \"active\": True}\n)\n</code></pre> <p>It is an equivalent of:</p> <pre><code>count: int = session.query(User).filter(\n    User.age &gt; 21, User.active == True\n).count()\n</code></pre>"},{"location":"migration_to_sqlalchemy/#same-with-find","title":"Same with find","text":"<pre><code>for u in redbean.find(\n    'user',\n    query=\"age &gt; :age and active = :active\",\n    params={\"age\": 21, \"active\": True}\n):\n    print(dict(u))\n</code></pre> <p>It is an equivalent of:</p> <pre><code>for u in (\n        session.\n        query(User).\n        filter(\n            User.age &gt; 21,\n            User.active == True,\n        ).\n        all()\n):\n    print(u.as_dict())\n</code></pre>"},{"location":"migration_to_sqlalchemy/#create","title":"Create","text":"<pre><code>user = Bean('user', {'id': \"1\", \"name\": \"Adam\"})\nredbean.store(user)\n#(...)\nredbean.store(user)\n</code></pre> <p>In RedBeanPython, this code will work; the second object will replace the first one.</p> <p> RedBeanPython operations are idempotent by design.</p> <p>But in SQLAlchemy, this code will throw an exception because of a unique constraint violation.</p> <pre><code>user = User()\nuser.id = \"3\"\nuser.name = \"Hanna\"\n\nsession.add(user)\nsession.commit()\n#(...)\nsession.add(user)\nsession.commit()\n</code></pre>"},{"location":"migration_to_sqlalchemy/#_1","title":"SQLAlchemy equivalents","text":""},{"location":"migration_to_sqlalchemy/#___","title":"___","text":""},{"location":"performance/","title":"Performance","text":""},{"location":"performance/#introduction","title":"Introduction","text":"<p>Most of the operations in RedBeanPython work with similar complexity as SQLAlchemy. However, RedBeanPython specification makes few operations more complex than SQLAlchemy equivalents.</p>"},{"location":"performance/#operations-with-more-extensive-complexity","title":"Operations with more extensive complexity","text":"<ul> <li>Store/Add. Complexity <code>2x</code> regarding SQLAlchemy.</li> <li>Update. Complexity <code>2x</code> regarding SQLAlchemy.</li> </ul>"},{"location":"performance/#performance-improvements","title":"Performance improvements","text":"<p>For most cases where RedBeanPython is dedicated, performance will be more than enough.</p> <p>But when you start to work on the scale, you can use some of these tips:</p> <ul> <li>Add indexes to your tables. RedBeanPython does not automatically add indexes (it is planned in the following versions).</li> <li>Replace bulk operations with Hybrid Mode equivalents (see Bulk operations).</li> <li>Replace joined loading with Hybrid Mode equivalents (see Joined load).</li> </ul>"},{"location":"performance/#_1","title":"Performance","text":""},{"location":"performance/#___","title":"___","text":""},{"location":"quick_tour/","title":"Quick tour","text":"<p>Let's start with a simple example. We will create a simple application.</p> <p>Use case: - We have a bookstore. - Every day, our warehouse exports CSV files with actual stock. - We want to write an app to manage selling. - After-sell invoices should be stored in the system. - At the end of the day, we should be able to print all invoices for a given day.</p> <p>An example will be written with trivial code, without frameworks, to show how to use RedBeanPython.</p> <p>At the end of this tutorial, you will find a complete example code that you can copy and run.</p>"},{"location":"quick_tour/#loading-data","title":"Loading data","text":"<p>First, install RedBeanPython:</p> <pre><code>pip install redbeanpython\n</code></pre> <p>The CSV file <code>warehouse.csv</code> that our warehouse exports every day has a structure like this:</p> <pre><code>Title,ISBN,Price,Quantity\n\"Dune\",\"9780441013593\",12.99,8\n\"Ender's Game\",\"9780812550702\",7.99,0\n\"The Hitchhiker's Guide to the Galaxy\",\"9780345391803\",6.99,20\n\"Neuromancer\",\"9780441569595\",8.99,12\n(...)\n</code></pre> <p>Let's import it to the database:</p> <pre><code>from decimal import Decimal\n\nfrom redbeanpython import Bean, r\n\n#We will use the SQLite database stored in the current directory\nr.setup(dsn=\"sqlite:///test.sqlite\")\n\nwith open('warehouse.csv', newline='') as csvfile:\n    for row in csv.DictReader(csvfile):\n        # create new bean\n        book = Bean('book')\n        # and fill it with data from the CSV\n        book.id = row['ISBN']\n        book.title = row['Title']\n        # We will use Decimal type for the price\n        book.price = Decimal(row['Price'])\n        book.quantity = int(row['Quantity'])\n        # and that's all, store it\n        r.store(book)\n</code></pre> <p>When we run this code, we store all books from the CSV file in a database. Nothing else is needed.</p> <p>Now we can start selling books.</p> <pre><code>from datetime import date\n\nfrom redbeanpython import NotExistsError\n\n# We want to create an invoice for every book we sell\ninvoice = Bean('invoice')\n\n# As invoices have to be enumerated consistently, we have to find the  last invoice number\ninvoice_id = 0\n\nif r.count('invoice') != 0:\n    # If there are any invoices in the database,\n    # we will find the last one\n    # and use its id as the previous number\n    last_invoice = list(r.find('invoice', order='id DESC', limit=1))[0]\n    invoice_id = int(last_invoice.id) + 1\n\ninvoice.id = str(invoice_id)\n\ninvoice.customer = input('What is the customer name?\\n')\ninvoice.issue_date = date.today()\ninvoice.total = Decimal('0.0')\n\nwhile True:\n    isbn = input('What is the ISBN of the book you want to sell?\\n')\n    try:\n        # We will try to load the book from the database\n        book = r.load('book', isbn, throw_on_empty=True)\n\n        # And check if it is in stock\n        if book.quantity &gt; 0:\n            book.quantity -= 1\n            r.store(book)\n            invoice.total += book.price\n            invoice.book_id = book.id\n            r.store(invoice)\n            break\n        else:\n            print('Sorry, we are out of stock.\\n')\n    except NotExistsError:\n        print('Sorry, we do not have that book.\\n')\n        print('Chose one of the following:')\n        for book in r.find('book'):\n            print(f'- {book.title}')\n\nprint(f'Your invoice number: {invoice.id}')\n</code></pre> <p>If we rerun this code, we observe that the database structure was extended. </p> <p>Now lets print all invoices for the given day:</p> <pre><code>invoice_date = input('What is the date of the invoices you want to print? (YYYY-MM-DD)\\n')\ninvoice_date = date.fromisoformat(invoice_date)\nfor invoice in r.find('invoice', query=\"issue_date = :date\", params={'date': invoice_date}):\n    print(f'Invoice {invoice.id} for {invoice.customer} with total {invoice.total:.2f}')\n    book = r.load(\"book\", invoice.book_id)\n    print(f'  Book: {book.title}')\n</code></pre> <p>Finally, we would need some stats of our business:</p> <pre><code>invoices_total = r.count('invoice')\nprint(f\"Total invoices: {invoices_total}\")\nout_of_stock = r.find('book', query=\"quantity = 0\")\nprint(f\"Out-of-stock books:\")\nfor book in out_of_stock:\n    print(f\"- {book.title} {book.id}\")\n</code></pre> <p>And that's all. We have a simple application to manage our bookstore.</p> <p>Let's check how it works:</p> <pre><code>  Generating migrations/versions/1706778405406427_.py # (1)\nWhat do you want to do? (\"sell_books\", \"print_invoices\", \"show_stats\", \"exit\")\n  sell_books\nWhat is the customer name?\n  Adam\nWhat is the ISBN of the book you want to sell?\n  9780441013593\n  Generating migrations/versions/1706778427235189_.py ...  done # (2)\nYour invoice number: 1\n\nWhat do you want to do? (\"sell_books\", \"print_invoices\", \"show_stats\", \"exit\")\n  sell_books\nWhat is the customer name?\n  Ivona\nWhat is the ISBN of the book you want to sell?\n  9780812550702\nSorry, we are out of stock.\n\nWhat is the ISBN of the book you want to sell?\n  1234\nSorry, we do not have that book.\n\nChose one of:\n- Dune 9780441013593\n- Ender's Game 9780812550702\n- The Hitchhiker's Guide to the Galaxy 9780345391803\n- Neuromancer 9780441569595\n\nWhat is the ISBN of the book you want to sell?\n  9780441569595\nYour invoice number: 2\n\nWhat do you want to do? (\"sell_books\", \"print_invoices\", \"show_stats\", \"exit\")\n  print_invoices\nWhat is the date of the invoices you want to print? (YYYY-MM-DD)\n  2024-02-01\nInvoice 1 for Adam with total 12.99\n  Book: Dune\nInvoice 2 for Ivona with total 8.99\n  Book: Neuromancer\n\nWhat do you want to do? (\"sell_books\", \"print_invoices\", \"show_stats\", \"exit\")\n  show_stats\nTotal invoices: 2\nOut of stock books:\n- Ender's Game 9780812550702\n\nWhat do you want to do? (\"sell_books\", \"print_invoices\", \"show_stats\", \"exit\")\n  exit\nBye!\n</code></pre> <ol> <li>Migration has been generated in the background as we load books for the first time.</li> <li>We are adding an invoice to the database for the first time, so migration has been generated in the background.</li> </ol>"},{"location":"quick_tour/#full-code","title":"Full code","text":"<p>If you want to check yourselves, install RedBeanPython, copy, and run this code.</p> <pre><code>#!/usr/bin/env python3\n# coding: utf-8\n\nimport csv\nfrom datetime import date\nfrom decimal import Decimal\n\nfrom redbeanpython import Bean, r, NotExistsError\n\nr.setup(dsn=\"sqlite:///test.sqlite\")\n\n# Create some test data to play with\nwith open('warehouse.csv', 'w') as f:\n    f.write(\"\"\"Title,ISBN,Price,Quantity\n\"Dune\",\"1\",12.99,8\n\"Ender's Game\",\"2\",7.99,0\n\"The Hitchhiker's Guide to the Galaxy\",\"3\",6.99,20\n\"Neuromancer\",\"4\",8.99,12\"\"\")\n\nwith open('warehouse.csv', newline='') as csvfile:\n    for row in csv.DictReader(csvfile):\n        book = Bean('book')\n        book.id = row['ISBN']\n        book.title = row['Title']\n        book.price = Decimal(row['Price'])\n        book.quantity = int(row['Quantity'])\n        r.store(book)\n\nwhile True:\n    match input('What do you want to do? (\"sell_books\", \"print_invoices\", \"show_stats\", \"exit\")\\n'):\n        case 'sell_books':\n            invoice = Bean('invoice')\n            invoice_id = 1\n            if r.count('invoice') != 0:\n                last_invoice = list(r.find('invoice', order='id DESC', limit=1))[0]\n                invoice_id = int(last_invoice.id) + 1\n            invoice.id = str(invoice_id)\n            invoice.issue_date = date.today()\n            invoice.customer = input('What is the customer name?\\n')\n            invoice.total = Decimal('0.0')\n\n            while True:\n                isbn = input('What is the ISBN of the book you want to sell?\\n')\n                try:\n                    book = r.load('book', isbn, throw_on_empty=True)\n                    if book.quantity &gt; 0:\n                        book.quantity -= 1\n                        r.store(book)\n                        invoice.total += book.price\n                        invoice.book_id = book.id\n                        r.store(invoice)                        \n                        break\n                    else:\n                        print('Sorry, we are out of stock.\\n')\n                except NotExistsError:\n                    print('Sorry, we do not have that book.\\n')\n                    print('Chose one of the following:')\n                    for book in r.find('book'):\n                        print(f'- {book.title} {book.id}')\n\n            print(f'Your invoice number: {invoice.id}')\n\n        case 'print_invoices':\n            invoice_date = input('What is the date of the invoices you want to print? (YYYY-MM-DD)\\n')\n            try:\n                invoice_date = date.fromisoformat(invoice_date)\n            except ValueError:\n                print('Sorry, I did not understand that format.')\n                break\n            for invoice in r.find('invoice', query=\"issue_date = :date\", params={'date': invoice_date}):\n                print(f'Invoice {invoice.id} for {invoice.customer} with total {invoice.total:.2f}')\n                book = r.load(\"book\", invoice.book_id)\n                print(f'  Book: {book.title}')\n\n        case 'show_stats':\n            invoices_total = r.count('invoice')\n            print(f\"Total invoices: {invoices_total}\")\n            out_of_stock = r.find('book', query=\"quantity = 0\")\n            print(f\"Out-of-stock books:\")\n            for book in out_of_stock:\n                print(f'- {book.title} {book.id}')\n        case 'exit':\n            print('Bye!')\n            exit(0)\n        case _:\n            print('Sorry, I did not understand that command.')\n</code></pre>"},{"location":"quick_tour/#_1","title":"Quick Tour","text":""},{"location":"quick_tour/#___","title":"___","text":""},{"location":"roadmap/","title":"Roadmap","text":"<p>Current version 1.0.0 is production-ready, covered by tests on various databases and package versions, but version 1.0.0 contains only the absolute minimum of features. As an idea, RedBeanPython will never be as feature-rich as SQLAlchemy, as its goal is different: to work hybrid with SQLAlchemy. For example, bulk operations or joined loading are not considered to be ever implemented in RedBeanPython, as if we have such cases, hybrid mode and SQLAlchemy should be used directly in such places. But to be fully functional, three main features are needed: transactions, relations and indexes. Planned to add the following versions:</p> <ul> <li>Transactions</li> </ul> <pre><code>with redbean.transaction() as t:\n    subscription = Bean('subscription')\n    user.price = Decimal('9.99')\n    t.store(subscription)\n    user = Bean('user')\n    user.name = \"Adam\"\n    user.age = 42\n    user.subscription_id = subscription.id\n    t.store(user)\n</code></pre> <ul> <li>Relations</li> </ul> <pre><code>subscription = Bean('subscription', ...)\n\ninvoices = [\n    Bean('invoice', ...),\n    Bean('invoice', ...),\n]\n\nuser = Bean('user')\nuser.subscription = subscription\nuser.invoices = invoices \n</code></pre> <ul> <li>Indexes</li> </ul> <pre><code>user().index('name', 'age')\n</code></pre>"},{"location":"roadmap/#_1","title":"Roadmap","text":""},{"location":"roadmap/#___","title":"___","text":""},{"location":"supported_versions/","title":"Compatibility table","text":""},{"location":"supported_versions/#python-versions","title":"Python versions","text":"<ul> <li>Python 3.11, 3.12</li> </ul>"},{"location":"supported_versions/#supported-databases","title":"Supported databases","text":"<ul> <li> <p>PostgreSQL: 9.0.23+ (tested with 9.0.23, 16.1 (latest))</p> </li> <li> <p>MySql: 8.0.0+ (tested with 8.0.0, 8.3.0 (latest))</p> </li> <li> <p>MariaDB: 10.4.0+ (tested with 10.4.0, 11.2.2 (latest))</p> </li> </ul>"},{"location":"supported_versions/#supported-packages","title":"Supported packages","text":"<ul> <li> <p>SQLAlchemy: 2.0.0+ (tested with 2.0.0, 2.0.25 (latest))</p> </li> <li> <p>psygopg: 3.0.18+ (tested with 3.0.18, 3.1.17 (latest))</p> </li> <li> <p>PyMySQL: 1.0.2+ (tested with 1.0.2, 1.1.0 (latest))</p> </li> <li> <p>alembic: 1.8.0+ (tested with 1.8.0, 1.13.1 (latest))</p> </li> </ul>"},{"location":"supported_versions/#compatibility-status","title":"Compatibility status","text":"<p>Each version of RedBeanPython has been tested with a full suite of tests against the following versions of Python, databases and packages:</p> <p>Tests results:</p> database python packages status postgres (postgres:16.1) 3.12 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK postgres (postgres:16.1) 3.12 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK postgres (postgres:16.1) 3.11 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK postgres (postgres:16.1) 3.11 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK postgres (postgres:9.0.23) 3.12 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK postgres (postgres:9.0.23) 3.12 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK postgres (postgres:9.0.23) 3.11 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK postgres (postgres:9.0.23) 3.11 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mysql:8.3.0) 3.12 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mysql:8.3.0) 3.12 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mysql:8.3.0) 3.11 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mysql:8.3.0) 3.11 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mysql:8.0.0) 3.12 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mysql:8.0.0) 3.12 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mysql:8.0.0) 3.11 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mysql:8.0.0) 3.11 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mariadb:11.2.2) 3.12 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mariadb:11.2.2) 3.12 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mariadb:11.2.2) 3.11 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mariadb:11.2.2) 3.11 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mariadb:10.4.0) 3.12 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mariadb:10.4.0) 3.12 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK mysql (mariadb:10.4.0) 3.11 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK mysql (mariadb:10.4.0) 3.11 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK sqlite (build-in) 3.12 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK sqlite (build-in) 3.12 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK sqlite (build-in) 3.11 latest (2024) ['SQLAlchemy==2.0.25', 'psycopg==3.1.17', 'PyMySQL==1.1.0', 'alembic==1.13.1']  OK sqlite (build-in) 3.11 legacy (2022) ['SQLAlchemy==2.0.0', 'psycopg==3.0.18', 'PyMySQL==1.0.2', 'alembic==1.8.0']  OK"},{"location":"supported_versions/#_1","title":"Compatibility Table","text":""},{"location":"supported_versions/#___","title":"___","text":""},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#development-tools","title":"Development tools","text":""},{"location":"tools/#clearing-models-and-migrations","title":"Clearing models and migrations","text":"<p>If you want to clear all models and migrations, use the <code>redbean clear</code> command.</p> <p>It is helpful during development to recreate models based on database content. </p> <p>For example, when we switch from one test database to another.</p> <pre><code># before\nredbean.setup(dsn=False)\n\n# now\nredbean.setup('postgresql+psycopg://postgres:pass@localhost/postgres')\n</code></pre> <pre><code>redbean clear_models\n</code></pre> <p>By default, the model's directory is <code>redbean</code>. But it can be overridden by</p> <pre><code>redbean clear_models --directory my_module/my_redbean\n</code></pre> <p>or via environment variable:</p> <pre><code>REDBEAN_DIRECTORY=my_module/my_redbean redbean clear_models\n</code></pre>"},{"location":"tools/#nuke","title":"Nuke","text":"<p>Nuke, as their name suggests, is a tool for destroying everything.</p> <p>Nuke is a helpful command in the early stage of development. It removes all models and migrations and clears the whole database.</p> <p> For security reasons, <code>nuke</code> may only be fired against the localhost or local container database. Running a nuke against the remote database is not possible.</p>"},{"location":"tools/#usage","title":"Usage:","text":"<p><pre><code>redbean nuke --dsn postgresql+psycopg://postgres:pass@localhost/postgres\n</code></pre> Or via environment variables: <pre><code>REDBEAN_DB_DSN=postgresql+psycopg://postgres:pass@localhost/postgres redbean nuke\n</code></pre></p> <p> If any <code>--dsn</code> nor <code>REDBEAN_DB_DSN</code> environment variable is provided, then the test base (created by <code>setup(dsn=False)</code>) will be removed.</p>"},{"location":"tools/#_1","title":"Tools","text":"<p>By default, the namespace and models directory are <code>redbean</code>. But can be overridden by</p> <pre><code>redbean nuke --dsn postgresql+psycopg://postgres:pass@localhost/postgres --namespace my_module --directory my_module/my_redbean\n</code></pre> <p>Or via environment variables:</p> <pre><code>REDBEAN_DB_DSN=postgresql+psycopg://postgres:pass@localhost/postgres REDBEAN_NAMESPACE=my_module REDBEAN_DIRECTORY=my_module/my_redbean redbean nuke\n</code></pre>"},{"location":"tools/#_2","title":"Tools","text":""},{"location":"tools/#___","title":"___","text":""},{"location":"types/","title":"Supported types","text":"<p>The idea of RedBeanPython is to focus on Python types instead of SQL-like types. So instead of focusing on SQLAlchemy <code>String</code> vs <code>Text</code> or <code>Integer</code> vs <code>BigInteger</code>, you can concentrate on Python types like <code>str</code> or <code>int</code>.</p> <p>RedBeanPython supports the storage of the following Python types:</p> <ul> <li><code>bool</code></li> <li><code>int</code></li> <li><code>float</code></li> <li><code>decimal</code></li> <li><code>str</code></li> <li><code>datetime</code> </li> <li><code>date</code></li> <li><code>bytes</code></li> </ul>"},{"location":"types/#types-auto-detection","title":"Types auto detection","text":"<p>The first usage determines types. (First storage in the database)</p> <pre><code>bean = Bean('user')\nbean.name = \"Adam\"\nbean.start_date_time = datetime.now()\nbean.start_date = date.today()\nbean.count = 1\nbean.ratio = 1.1\nbean.price = Decimal(\"1.1\")\nbean.binary_code = b\"123\"\n</code></pre> <p>The first usage determines types. It is very efficient in the development stage but, at the same time, is safe for production as production database practice is to be frozen (check Freezing database). As a good practice, we check all autogenerated database migrations before committing them to the repository and deploying them on production.</p> <p>no matter what happens, the production database will not be changed without our explicit permission.   </p>"},{"location":"types/#nullable","title":"Nullable","text":"<p>All types are nullable by default.</p>"},{"location":"types/#id","title":"Id","text":"<p>Id is always stored as <code>String(255)</code>, and its type can not be enforced. </p>"},{"location":"types/#advanced-deep-into-used-database-types","title":"(Advanced) Deep into used database types","text":"<p>By default, to have confidence, all possible variations of values that can go in future will be stored successfully; RedBeanPython always uses a type that covers the maximum range.</p> <p>For example:</p> <pre><code>bean.name = \"Adam\"\nbean.count = 1\nbean.price = Decimal(1.1)\n# ect.\nredbean.store(bean)\n</code></pre> <p>In theory, those values can be stored in the database as, consecutively: </p> <ul> <li>SQLAlchemy String(4) (in DB: varchar(4)),</li> <li>SmallInteger (in DB: smallint (2 bytes))</li> <li>Decimal(precision=2,scale=1) (in DB: decimal(2,1))</li> </ul> <p>But in practice, with autodetection, we do not know what values will be stored in future, so we need to use the type that covers the maximum range.</p> <p>What if, after freezing the database, the production system will try to store values that are out of range of column type? For example: <pre><code>bean.name = \"Longer name\"\nbean.count = 1_000_000\nbean.price = Decimal(1001.1005)\nredbean.store(bean)\n</code></pre></p> <p>That's why auto detection will always use the maximum range type.</p> <ul> <li><code>int</code> -&gt; <code>BigInteger</code> (8 bytes)`</li> <li><code>float</code> -&gt; <code>Double</code> (8 bytes)</li> <li><code>decimal</code> -&gt; <code>Numeric(precision=30, scale=10)</code> (17 bytes)</li> <li><code>str</code> -&gt; <code>Text</code> (dynamic size)</li> </ul> <p>In the case of <code>str</code>:</p> <p>As they are dynamic, there is no redundant storage needed.</p> <p>And looking from a performance point of view:</p> <ul> <li>in the case of PostgreSQL: there is no problem at all. There is no performance difference between <code>text</code> and <code>varchar</code>.</li> <li>in the case of MySQL, there is a performance drop. Because TEXTs are stored outside the row and have to be loaded first. It is usually OK in practice, but consider PostgreSQL usage if you expect more data to be stored/loaded/searched.       </li> </ul> <p>If, in your system, you achieve the amount of data on which this starts to be a problem (f.e. that 4 or 6 redundant bytes per integer row is a problem), then it means your project is mature enough to alter tables to smaller types and switch to SQLAlchemy as id described in Hybrid mode.</p>"},{"location":"types/#_1","title":"Types","text":""},{"location":"types/#___","title":"___","text":""}]}